<html>

<head>
	<style>
		html {
			background-color: black;
		}

		#canvasRain {
			position: absolute;
			top: 0;
			left: 0;
			background-color: rgba(255, 255, 255, 0.2);
		}
	</style>
</head>

<body>
	<canvas id="canvasRain" width="320" height="600"></canvas>
	<script type="text/javascript">
		//var weatherCode = weather.icon();
		var weatherCode = 1; // this is for testing

		var snowCodes = [5, 6, 7, 13, 14, 15, 16, 41, 42, 43, 46]; // Weather codes that include snow in some way
		var rainCodes = [1, 2, 3, 4, 8, 9, 10, 11, 12, 35, 37, 38, 39, 40, 42, 45, 47];
		var cloudCodes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 26, 27, 28, 29, 30, 35, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47];
		var SVGAnimate;

		var weatherParts = [];

		if (snowCodes.indexOf(weatherCode) > -1) {
			weatherParts.push('snow');
			SVGAnimate = true;
		}
		if (rainCodes.indexOf(weatherCode) > -1) {
			weatherParts.push('rain');
			SVGAnimate = true;
		}
		if (cloudCodes.indexOf(weatherCode) > -1) {
			weatherParts.push('clouds');
			SVGAnimate = true;
		}

		var canvas = null;
		var context = null;
		var bufferCanvas = null;
		var bufferCanvasCtx = null;
		var flakeArray = {};
		var flakeTimer = {};
		//var maxFlakes = (snowCodes) ? 100 : 20;
		var flakeProperties = {
			'snow': {
				'max': 40,
				'spawnDelay': 200
			},
			'rain': {
				'max': 20,
				'spawnDelay': 200,
				'minSpeed': 7,
				'maxSpeed': 13,
				'minSize': 3,
				'maxSize': 5
			},
			'clouds': {
				'max': 3,
				'spawnDelay': false
			}
		};

		function randomInt(min, max) {
			return Math.floor(Math.random() * (max - min + 1) + min);
		}

		function randomNum(min, max) {
			return Math.random() * (max - min + 1) + min;
		}

		window.requestAnimFrame = (function() {
			return window.requestAnimationFrame ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame ||
				function(callback) {
					window.setTimeout(callback, 1000 / 60);
				};
		})();

		function Flake(type) {
			this.type = type;
			switch (type) {
				case 'rain':
					this.speed = {
						'x': 1,
						'y': randomInt(flakeProperties['rain']['minSpeed'], flakeProperties['rain']['maxSpeed'])
					};
					this.width = randomInt(flakeProperties['rain']['minSize'], flakeProperties['rain']['maxSize']);
					this.y = -10;
					this.position = {
						'xLeft': this.width / 2,
						'xRight': this.width / 2,
						'yUp': 7,
						'yDown': this.width / 2
					}
					break;
				case 'snow':
					this.speed = {
						'x': Math.random(),
						'y': Math.round(Math.random() * 5) + 1
					};
					this.width = (Math.random() * 3) + 2;
					this.y = -10;
					break;
				case 'clouds':
					this.sizeModifier = 1 + randomNum(-0.05, 0.05);
					var speedMultiplier = randomInt(1, 5);
					this.speed = {
						'x': randomNum(0.01 * speedMultiplier, 0.1 * speedMultiplier) * (1 / (this.sizeModifier) * 2), // Shouldn't be too much speed diff beween clouds, should be slow overall
						'y': 0
					};
					this.y = randomInt(30 * this.sizeModifier, 70 * this.sizeModifier);
					//this.width = this.x + 14 + (80 * this.sizeModifier) + ((28 * this.sizeModifier) / 2);
					this.position = {
						'xLeft': 28 * this.sizeModifier,
						'xRight': (80 * this.sizeModifier) + (28 * this.sizeModifier),
						'yUp': 23 * this.sizeModifier + (23 * this.sizeModifier),
						'yDown': 28 * this.sizeModifier
					};
					break;
			}
			this.x = Math.round(Math.random() * context.canvas.width);
			//this.y = -10;
			this.height = this.width;
			this.drawToCanvas = function(ctx) {
				switch (type) {
					case 'rain':
						ctx.fillStyle = "rgba(68, 144, 233, 0.5)";
						ctx.beginPath();
						ctx.moveTo(this.x - this.width / 2, this.y);
						ctx.lineTo(this.x, this.y - 7);
						ctx.lineTo(this.x + this.width / 2, this.y);
						ctx.arc(this.x, this.y, this.width / 2, 0, Math.PI);
						break;
					case 'snow':
						ctx.fillStyle = "rgba(255,255,255,0.8)";
						ctx.beginPath();
						ctx.arc(this.x, this.y, 2, 10, 0, true);
						break;
					case 'clouds':
						ctx.fillStyle = "rgba(69, 69, 69, 0.8)";
						ctx.beginPath();
						ctx.arc(this.x, this.y, 28 * this.sizeModifier, 0, 2 * Math.PI, false);
						ctx.arc(this.x + 24 * this.sizeModifier, this.y - 23 * this.sizeModifier, 23 * this.sizeModifier, 0, 2 * Math.PI, false);
						ctx.arc(this.x + 65 * this.sizeModifier, this.y - 17 * this.sizeModifier, 26 * this.sizeModifier, 0, 2 * Math.PI, false);
						ctx.arc(this.x + 80 * this.sizeModifier, this.y, 28 * this.sizeModifier, 0, 2 * Math.PI, false);
						ctx.lineTo(this.x + 80 * this.sizeModifier, this.y + 28 * this.sizeModifier);
						ctx.lineTo(this.x, this.y + 28 * this.sizeModifier);
						ctx.closePath();
						ctx.fill();

						ctx.fillStyle = "red";
						ctx.beginPath();

						break;
				}
				ctx.closePath();
				ctx.fill();
			}
		}

		function SVGinit() {
			canvas = document.getElementById('canvasRain');
			context = canvas.getContext("2d");
			bufferCanvas = document.createElement("canvas");
			bufferCanvasCtx = bufferCanvas.getContext("2d");
			bufferCanvasCtx.canvas.width = context.canvas.width;
			bufferCanvasCtx.canvas.height = context.canvas.height;
			addFlakes();
			Draw();
			(function animloop() {
				requestAnimFrame(animloop);
				animate();
			})();
		}

		function addFlakes() {
			for (var i = 0; i < weatherParts.length; i++) {
				flakeArray[weatherParts[i]] = []; // Create an empty array for each of the flake types

				if (flakeProperties[weatherParts[i]]['spawnDelay']) { // If it's something that should be introduced over a delay
					var weatherType = weatherParts[i];
					flakeTimer[weatherParts[i]] = setInterval(function() {
						addFlake(weatherType)
					}, flakeProperties[weatherParts[i]]['spawnDelay']); // Incrementally introduce the flakes
				} else { // They should all be introduced at the same time
					for (var k = 0; k < flakeProperties[weatherParts[i]]['max']; k++) {
						addFlake(weatherParts[i]);
					}
				}
			}
		}

		function addFlake(weatherType) {
			flakeArray[weatherType].push(new Flake(weatherType));
			console.log('WeatherType: ' + weatherType + ',' + flakeArray[weatherType].length + ',' + flakeProperties[weatherType]['max']);
			if (flakeArray[weatherType].length === flakeProperties[weatherType]['max'] && flakeTimer[weatherType]) { // If we've hit the max, and just verify it exists to prevent errors
				clearInterval(flakeTimer[weatherType]);
				console.log('Cleared');
			}
		}

		function blank() {
			context.save();
			bufferCanvasCtx.clearRect(0, 0, canvas.width, canvas.height);
			context.clearRect(0, 0, canvas.width, canvas.height);
		}

		function animate() {
			Update();
			Draw();
		}

		function Update() {
			Object.keys(flakeArray).forEach(function(key) {
				for (var i = 0; i < flakeArray[key].length; i++) {
					if (flakeArray[key][i].y - flakeArray[key][i].position['yUp'] <= context.canvas.height) {
						flakeArray[key][i].y += flakeArray[key][i].speed.y;
						if (flakeArray[key][i].y - flakeArray[key][i].position['yUp'] > context.canvas.height) // If it's gone beyond the bottom of the screen
							flakeArray[key][i].y = flakeArray[key][i].position['yDown'] * -1;
						flakeArray[key][i].x += flakeArray[key][i].speed.x;
						if (flakeArray[key][i].x - flakeArray[key][i].position['xLeft'] > context.canvas.width)
							flakeArray[key][i].x = flakeArray[key][i].position['xRight'] * -1;
					}
				}
			});
		}

		function Draw() {
			context.save();
			blank();

			Object.keys(flakeArray).forEach(function(key) { // Go through each of the arrays for each type of flake
				for (var i = 0; i < flakeArray[key].length; i++) { // Go through each flake in this type
					flakeArray[key][i].drawToCanvas(bufferCanvasCtx); // Call its draw function
				}
			});

			context.drawImage(bufferCanvas, 0, 0, bufferCanvas.width, bufferCanvas.height);
			context.restore();
		}

		if (SVGAnimate) {
			SVGinit();
		}
	</script>

</body>

</html>
